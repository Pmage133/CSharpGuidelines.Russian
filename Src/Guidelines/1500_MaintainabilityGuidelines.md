<!--
NOTE: Requires Markdown Extra. See http://michelf.ca/projects/php-markdown/extra/
 --> 

#5. Рекомендации по улучшению сопровождаемости кода

### <a name="av1500"></a> В методе не должно быть более 7 объявлений (AV1500) ![](images/1.png)
Метод, который включает в себя более 7 объявлений, скорей всего делает слишком много или берет на себя слишком большую ответственность. Кроме того, человеческая память требует, чтобы метод был коротким. Она не в состоянии удерживать в себе одновременно большее количество вещей, чтобы точно проанализировать и понять, что делает тот или иной кусок кода. Разделите метод на несколько маленьких, имеющих четкое предназначение, и дайте им имена, которые будут точно указывать на то, что они делают. При этом обратите внимание на то, чтобы алгоритм работы этой части программы оставался ясен для понимания.

### <a name="av1501"></a>Создавайте все члены класса `private`, а типы `internal` по умолчанию  (AV1501) ![](images/1.png)
Чтобы принять более взвешенное решение о том, какие элементы должны быть доступны другим классам, в первую очередь как можно больше ограничьте их область видимости. Затем тщательно подумайте, какие члены или типы действительно стоит сделать `public`.

### <a name="av1502"></a> Избегайте двойного отрицания (AV1502) ![](images/2.png)
Несмотря на то, что такое свойство, как `customer.HasNoOrders` имеет право на существование, избегайте его использования с отрицанием. Например:

	bool hasOrders = !customer.HasNoOrders;

Двойное отрицание более сложно для понимания, чем простое выражение, и люди склонны путаться в нем.

### <a name="av1505"></a> Название сборки должно соответствовать пространству имен, которое она содержит (AV1505) ![](images/3.png)
Все DLL должны именоваться в соответствии с паттерном  *Company*.*Component*.dll где *Company* это название вашей фирмы, а *Component*  — наименование одного или более пространства имен, разделенных точками. Например:

`AvivaSolutions.Web.Controls.dll`.

В качестве примера можно привести объединение группы классов в пространстве имен `AvivaSolutions.Web.Binding`, которое находится в определенной сборке.  Согласно данной рекомендации эта сборка должна быть названа `AvivaSolutions.Web.Binding.dll`. 

**Исключение:** Если вы решите связать классы из различных несвязанных пространств имен в одну сборку, добавьте суффикс `Core` к ее названию. Однако не используйте этот суффикс в названиях пространств имен. Например: `AvivaSolutions.Consulting.Core.dll`.

### <a name="av1506"></a> Называйте файлы с исходным кодом в соответствии с тем типом данных, который он содержит (AV1506) ![](images/3.png)
Используйте нотацию паскаль для именования файлов и не используйте подчеркивания.

### <a name="av1507"></a> Ограничивайте содержимое файла с исходным кодом одним типом данных  (AV1507) ![](images/3.png)
**Исключение:** Вложенные типы, по понятным причинам, должны быть частью того же самого файла.

### <a name="av1508"></a> Наименование файла с исходным кодом, который содержит частичный тип данных, должно отражать назначение этой части (AV1508) ![](images/3.png)
Когда используются частичные типы и идет разделение частей на файлы, имя каждого файла должно быть логически разделено на две части. Первая часть – название типа. Вторая – роль, которую данный фрагмент играет в типе. Например:

	// В файле MyClass.cs
	public partial class MyClass
	{...}
	
	// В файле MyClass.Designer.cs	
	public partial class MyClass
	{...}

### <a name="av1510"></a> Используйте `using` вместо указания полной ссылки на тип из другого пространства имен (AV1510) ![](images/3.png)
Не используйте полную ссылку на тип из другого пространства имен в целях предотвращения конфликтов именования. Например, не делайте так:

	var list = new System.Collections.Generic.List();

Лучше сделать так:

	using System.Collections.Generic;
	
	var list = new List();

Если вам необходимо избежать конфликтов именования, используйте директиву `using` для создания псевдонима пространства имен или типа:

	using Label = System.Web.UI.WebControls.Label;

### <a name="av1515"></a> Не используйте «магические» числа (AV1515) ![](images/1.png)
Не используйте литеральные значения, числа или строки в вашем коде ни для чего другого, кроме как для объявления констант. Для примера:

	public class Whatever  
	{
		public static readonly Color PapayaWhip = new Color(0xFFEFD5);
		public const int MaxNumberOfWheels = 18;  
	}

Строки, предназначенные для логирования или трассировки, являются исключением из этого правила. Литеральные значения допускается использовать только тогда, когда их смысл ясен из контекста и их не планируется изменять. Например:

	mean = (a + b) / 2; // среднее арифметическое 
	WaitMilliseconds(waitTimeInSeconds * 1000); // тут тоже все понятно

Если значение одной константы зависит от значения другой, укажите это в своем коде.

	public class SomeSpecialContainer  
	{  
		public const int MaxItems = 32;  
		public const int HighWaterMark = 3 * MaxItems / 4; // 75%  
	}

**Заметка:** Перечисления часто могут использоваться в качестве хранилища символьных констант.

### <a name="av1520"></a> Используйте `var` только тогда, когда тип переменной очевиден (AV1520) ![](images/1.png)
Используйте `var` только в том случае, если переменной присваивается результат LINQ-запроса или если тип переменной очевиден и использование var повысит читаемость кода. Например, так делать не стоит:

	var i = 3;									// Что за тип? int? uint? float?
	var myfoo = MyFactoryMethod.Create("arg");	// Не понятно, какой тип имеет	
												// класс или интерфейс. Кроме того,
												// тяжело изменять код, который работает 
												// c этой переменной, если исходный класс
                                                // вам недоступен

Вместо этого используйте var как в примерах ниже:

	var q = from order in orders where order.Items > 10 and order.TotalValue > 1000;
	var repository = new RepositoryFactory.Get();	
	var list = new ReadOnlyCollection();

Во всех трех примерах тип присваиваемых переменным значений очевиден. Для получения более подробной информации об использовании `var` читайте статью Ерика Липперта [Использование и злоупотребления неявной типизацией](http://blogs.msdn.com/b/ericlippert/archive/2011/04/20/uses-and-misuses-of-implicit-typing.aspx).

### <a name="av1521"></a> Объявляйте и инициализируйте переменные как можно позже (AV1521) ![](images/2.png)
Избегайте стиля языков C и VisualBasic, когда все переменные объявляются в начале блока. Объявляйте и инициализируйте каждую переменную только тогда, когда она необходима.

### <a name="av1522"></a> Присваивайте значение каждой переменной в отдельном объявлении (AV1522) ![](images/1.png)
Никогда не делайте так:

	var result = someField = GetSomeMethod();

### <a name="av1523"></a> Предпочитайте инициализаторы объектов и коллекций раздельной установке свойств и раздельному добавлению новых объектов в коллекцию (AV1523) ![](images/2.png)
Вместо такой конструкции:

	var startInfo = new ProcessStartInfo("myapp.exe");	
	startInfo.StandardOutput = Console.Output;
	startInfo.UseShellExecute = true;

Используйте [инициализатор объекта](http://msdn.microsoft.com/en-us/library/bb384062.aspx):

	var startInfo = new ProcessStartInfo("myapp.exe")  
	{
		StandardOutput = Console.Output,
		UseShellExecute = true  
	};

Вместо создания коллекции — таким образом:

	var countries = new List();
	countries.Add("Netherlands");
	countries.Add("United States");

Используйте инициализатор коллекции или [словаря](http://msdn.microsoft.com/en-us/library/bb531208.aspx):

	var countries = new List { "Netherlands", "United States" };

### <a name="av1525"></a> Не производите явного сравнения с `true` или `false` (AV1525) ![](images/1.png)

Сравнение логического значения с `true` или `false` – это, как правило, плохой стиль программирования. В качестве примера:

	while (condition == false)// неправильно, плохой стиль 
	while (condition != true)// тоже неправильно  
	while (((condition == true) == true) == true)// где ты остановишься?
	while (condition)// OK

### <a name="av1530"></a> Не изменяйте переменную цикла `for` или `foreach` внутри тела цикла (AV1530) ![](images/2.png)
Обновление переменной цикла внутри тела цикла ведет к тому, что код становится запутанным. Особенно, если переменная изменяется более чем в одном месте.

	for (int index = 0; index < 10; ++index)  
	{  
		if (_some condition_)
		{
			index = 11; // Неправильно! Вместо этого используйте ‘break’ или ‘continue’. 
		}
	}

### <a name="av1532"></a> Избегайте вложенных циклов (AV1532) ![](images/2.png)
Методы, содержащие вложенные циклы, более сложны для понимания, чем те, которые содержат только один цикл. По факту, в большинстве случаев циклы могут быть заменены гораздо меньшим по размеру LINQ-запросом, который использует ключевое слово `from` два раза и более для объединения данных.

### <a name="av1535"></a> Всегда используйте конструкции `if`, `else`, `while`, `for`, `foreach` и `case` с фигурными скобками (AV1535) ![](images/2.png)
Пожалуйста, обратите внимание, что это также поможет избежать возможной путаницы с конструкциями вроде этой:

	if (b1) if (b2) Foo(); else Bar(); // к какому ‘if’ относится ‘else’?
	
	// Лучше сделать так:   
	if (b1)  
	{  
		if (b2)  
		{  
			Foo();  
		}  
		else  
		{  
			Bar();  
		}  
	}

### <a name="av1536"></a> Всегда используйте блок `default` в конце конструкции `switch/case` (AV1536) ![](images/1.png)
Если блок default будет пуст, добавьте поясняющий комментарий. Кроме того, если этот блок не должен быть достижимым, сгенерируйте при его вызове InvalidOperationException, чтобы обнаружить будущие изменения, при которых ни один из блоков case не будет достигнут. Следование этой рекомендации позволит вам писать более чистый код, потому что все сценарии выполнения уже были продуманы.

	void Foo(string answer)  
	{  
		switch (answer)  
		{  
			case "no":  
			{
			  Console.WriteLine("You answered with No");  
			  break;
			}  
			  
			case "yes":
			{  
			  Console.WriteLine("You answered with Yes");  
			  break;
			}
			
			default:  
			{
			  // Not supposed to end up here.  
			  throw new InvalidOperationException("Unexpected answer " + answer);
			}  
		}  
	}

### <a name="av1537"></a> Заканчивайте каждый блок `if-else-if` объявлением `else` (AV1537) ![](images/2.png)
Например:

	void Foo(string answer)  
	{  
		if (answer == "no")  
		{  
			Console.WriteLine("Вы ответили Нет");  
		}  
		else if (answer == "yes")  
		{  
			Console.WriteLine("Вы ответили Да");  
		}  
		else  
		{  
			// Что должно случиться, когда этот блок выполнится? Игнорировать это?    
			// Если нет, то  сгенерировать исключение InvalidOperationException.  
		}  
	}

### <a name="av1540"></a>Старайтесь избегать нескольких объявлений `return` (AV1540) ![](images/2.png)
Один вход — одна точка выхода, так звучит этот принцип. Он позволяет поддерживать понятным ход выполнения метода. При этом если метод очень маленький и соответствует рекомендации AV1500, тогда несколько объявлений return могут быть актуальными и улучшат читаемость кода. Например, если метод возвращает логическое значение, удобней использовать два объявления return вместо логической переменной, которую вернет метод и которой будут присваиваться значения по ходу его выполнения.

### <a name="av1545"></a> Не используйте блок `if-else` вместо простого (условного) присваивания (AV1545) ![](images/2.png)
Выражайте свои намерения прямо. Например, вместо этого:

	bool pos;
	
	if (val > 0)  
	{  
		pos = true;  
	}  
	else  
	{  
		pos = false;  
	}

Делайте так:

	bool pos = (val > 0); // инициализация

Вместо:

	string result;
	
	if (someString != null)
	{  
		result = someString;  
	}
	else
	{
		result = "Unavailable";
	}

	return result;

Пишите:

	return someString ?? "Unavailable";

### <a name="av1547"></a> Инкапсулируйте сложное выражение в методе или свойстве (AV1547) ![](images/1.png)
Рассмотрим следующий пример:

	if (member.HidesBaseClassMember && (member.NodeType != NodeType.InstanceInitializer))
	{
		// что-то делаем
	}

Чтобы понять, что делает этот код, вам придется вникать в его детали и предвидеть все варианты его выполнения. Конечно, вы можете добавить поясняющий комментарий перед этим кодом, но лучше замените сложное выражение методом, название которого будет говорить само за себя.

	if (NonConstructorMemberUsesNewKeyword(member))  
	{  
		// что-то делаем
	}  
  
  
	private bool NonConstructorMemberUsesNewKeyword(Member member)  
	{  
		return
			(member.HidesBaseClassMember &&
			(member.NodeType != NodeType.InstanceInitializer)  
	}

Если вам потребуется изменить этот метод, вам все равно придется разбираться в том, как он работает. Но теперь гораздо легче понять код, который его вызывает..

### <a name="av1551"></a> Вызывайте более перегруженный метод из других перегрузок (AV1551) ![](images/2.png)
Данное правило применимо только к тем методам, которые перегружены между собой необязательными аргументами. Посмотрите на пример ниже:

	public class MyString  
	{
		private string someText;
		
	    	public int IndexOf(string phrase)  
		{  
			return IndexOf(phrase, 0); 
		}
		
		public int IndexOf(string phrase, int startIndex)  
		{  
			return IndexOf(phrase, startIndex, someText.Length - startIndex);
		}
		
		public virtual int IndexOf(string phrase, int startIndex, int count)  
		{  
			return someText.IndexOf(phrase, startIndex, count);
		}  
	}

Класс `MyString` обеспечивает три перегрузки метода `IndexOf`, при этом две их них просто вызывают другую с большим количеством параметров. Заметьте, что это правило применимо к конструкторам класса. Реализуйте наиболее перегруженный конструктор и вызывайте его из других перегрузок, используя оператор `this()`. Также следует отметить, что параметры с одними и теми же именами должны следовать в одном и том же порядке во всех перегрузках.

**Важно:** Если вы хотите, чтобы поведение классов можно было менять с помощью переопределения данных методов, то объявите наиболее перегруженный метод как `protected virtual`, который вызывается всеми перегрузками.

### <a name="av1553"></a> Используйте необязательные аргументы только для того, чтобы заменять перегрузки (AV1553) ![](images/1.png)
Единственная допустимая причина для использования необязательных аргументов C# 4.0 – это замена примера из правила AV1551 одиночным методом наподобие этого:

	public virtual int IndexOf(string phrase, int startIndex = 0, int count = 0)
	{
		return someText.IndexOf(phrase, startIndex, count);
	}

Если необязательный параметр является ссылочным типом, то он может иметь в качестве значения по умолчанию только null. Но, как нам известно, string, list и collections никогда не должны быть равны null (согласно правилу AV1135). Поэтому вы должны использовать вместо этого перегруженный метод.

**Примечание:** Компилятор копирует значение необязательных параметров в место вызова. Поэтому, изменение значения по умолчанию для необязательных параметров должно сопровождаться рекомпиляцией вызывающего кода.

**Примечание:** Когда метод класса используется через интерфейс, то передача необязательных параметров не доступна до тех пор, пока объект, который содержит данный метод, не будет приведен к соответствующему классу. Смотрите [статью Эрика Липперта](http://blogs.msdn.com/b/ericlippert/archive/2011/05/09/optional-argument-corner-cases-part-one.aspx) для получения дополнительной интформации.

### <a name="av1555"></a> Избегайте использования именованных аргументов (AV1555) ![](images/1.png)
Именованные аргументы C# 4.0 были созданы для того, чтобы облегчить вызов COM компонентов, которые известны тем, что могут предлагать тонны необязательных параметров. Если вам нужны именованные аргументы, чтобы улучшить читаемость вызова для метода, скорее всего, этот метод делает слишком много и он должен быть подвергнут рефакторингу.

**Исключение:** Единственным исключением, когда именованые аргументы могут улучшить читаемость, является вызов метода с логическим параметром, исходный код которого вам не доступен. Например:  

	object[] myAttributes = type.GetCustomAttributes(typeof(MyAttribute), inherit: false);

### <a name="av1561"></a>Не допускайте, чтобы метод или конструктор принимал более трех параметров (AV1561) ![](images/1.png)
Если ваш метод или конструктор принимает более чем три параметра, используйте структуру или класс для их инкапсуляции их в соответствии с паттерном [спецификация](http://en.wikipedia.org/wiki/Specification_pattern). В общем случае, чем меньше число параметров, тем легче понять метод. К тому же юнит-тестирование метода с множеством параметров требует множество сценариев для тестирования.

### <a name="av1562"></a> Не используйте `ref` и `out` в параметрах (AV1562) ![](images/1.png)
Они делают код менее понятным и создают предпосылки для ошибок. Вместо этого возвращайте составные объекты в качестве результата выполнения функции.

### <a name="av1564"></a>Не создавайте методы, которые принимают в качестве параметра логическое значение (AV1564) ![](images/2.png)
Посмотрите на следующий метод:

	public Customer CreateCustomer(bool platinumLevel) {}

На первый взгляд все выглядит замечательно, но когда вы будете использовать этот метод, смысл логической переменной полностью потеряет свою ясность:


	Customer customer = CreateCustomer(true);

Обычно, если метод принимает булевый флаг в качестве параметра, то он делает более, чем одну вещь и нуждается в рефакторинге для разделения на два или более метода. Альтернативным решением является замена флага перечислением.

### <a name="av1568"></a> Не используйте параметры в качестве временных переменных (AV1568) ![](images/3.png)
Никогда не используйте параметр в качестве внутренней переменной. Даже если тип параметра может совпадать с тем типом, который вам требуется, то название, как правило, не будет отражать цели временной переменной.

### <a name="av1570"></a> Всегда проверяйте результат, возвращаемый оператором `as` (AV1570) ![](images/1.png)
Если вы используйте оператор `as` чтобы привести объект к определенному интерфейсу, то всегда проверяйте возвращаемый им результат на `null`. Невыполнение этого требования может привести к исключению `NullReferenceException` на гораздо поздней стадии выполнении программы, если объект не реализует требуемый интерфейс.

### <a name="av1575"></a> Не оставляйте закомментированные участки кода (AV1575) ![](images/1.png)
Никогда не отправляйте в репозиторий закомментированный код. Вместо этого используйте систему трекинга задач, чтобы следить за тем, какая работа должна быть сделана. Никто впоследствии не догадается, для чего предназначен тот или иной блок закомментированного кода. Он был временно закомментирован для тестирования? Он был скопирован в качестве примера? Должен ли я удалить его?
