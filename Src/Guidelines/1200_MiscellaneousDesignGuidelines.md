<!--
NOTE: Requires Markdown Extra. See http://michelf.ca/projects/php-markdown/extra/
 --> 

# 4. Общие рекомендации по проектированию

### <a name="av1200"></a> Генерируйте исключение вместо возвращения статусного сообщения (AV1200) ![](images/2.png)

Кодовая база, которая использует возвращаемое статусное сообщение для определения завершилась ли операция успешно или нет, зачастую имеет вложенные `if` выражения, разбросанные по всему коду. Зачастую пользователи забывают проверить возвращаемое значение. Структурированная обработка исключений была введена для того, чтобы позволить вам генерировать исключения и отлавливать или заменять их на более высоком уровне. В большинстве систем является довольно распространенной практикой генерировать исключения всякий раз, когда происходит неожиданная ситуация.

### <a name="av1202"></a> Обеспечьте полное и осмысленное сообщение об исключении (AV1202) ![](images/2.png)

Сообщение должно объяснять, что привело к исключению и ясно описывать, что нужно сделать, чтобы избежать его в дальнейшем.

### <a name="av1205"></a> Генерируйте настолько специфичное исключение, насколько это возможно (AV1205) ![](images/3.png)

Например, если метод принял в качестве входного параметра `null`, следует сгенерировать `ArgumentNullException` вместо `ArgumentException`.

### <a name="av1210"></a> Не игнорируйте ошибку путем обработки общих исключений (AV1210) ![](images/1.png)

Не игнорируйте ошибки путем обработки общих исключений, таких как `Exception`, `SystemException` и другие в коде приложения. Только обработчик ошибок самого верхнего уровня должен отлавливать общие исключения с целью логирования и корректного завершения работы приложения.

### <a name="av1215"></a> Обрабатывайте исключения в асинхронном коде должным образом (AV1215) ![](images/2.png)
Когда вы генерируете или обрабатываете исключения в коде, который использует `async`/`await` или `Task` помните о следующих двух правилах:

- Исключения, которые возникают в пределах блоков `async`/`await` и внутри `Task`, распространяются на задачу, которая ожидает выполнение этих блоков.
- Исключения, которые возникли в коде, предшествующем `async`/`await` и `Task`, распространяются на вызывающий код.

### <a name="av1220"></a> Всегда проверяйте делегат обработчика события на `null` (AV1220) ![](images/1.png)

Событие, которое не имеет подписок, равно `null`. Таким образом, перед тем, как оно будет вызвано, убедитесь, что список делегатов, представляющих это событие, не равен `null`. Кроме того, чтобы избежать конфликтов при изменении из параллельных потоков, используйте временную переменную, чтобы избежать одновременного изменения.

	event EventHandler Notify;
	
	void RaiseNotifyEvent(NotifyEventArgs args)  
	{
		EventHandler handlers = Notify;  
		if (handlers != null)  
		{  
		    handlers(this, args); 
		}
	}

**Подсказка:** Вы можете сделать так, чтобы список делегатов не был совсем пустым. Просто объявите пустой делегат так, как показано ниже:

	event EventHandler Notify = delegate {};

### <a name="av1225"></a> Для вызова каждого события используйте защищенный виртуальный метод (AV1225) ![](images/2.png)
Выполнение этой рекомендации позволит производным классам обрабатывать событие базового класса путем переопределения защищенного метода. Название защищенного виртуального метода должно быть таким же, как название события, но с префиксом `On`. Например, защищенный виртуальный метод для события с названием `TimeChanged` должен быть назван `OnTimeChanged`.

**Подсказка:** От производных классов, которые переопределяют защищенный виртуальный метод, не требуется вызывать реализацию базового класса. Базовый класс должен продолжать свою работу корректно, даже если его реализация не вызвана.

### <a name="av1230"></a> Использование событий уведомления об изменении свойств (AV1230) ![](images/3.png)
Событие уведомления об изменении свойства должно иметь название наподобие `PropertyChanged`, где `Property` должно быть изменено на название свойства, с которым связано это событие.

**Подсказка:** Если ваш класс имеет множество свойств, которые требуют соответствующих событий, попробуйте реализовать вместо этого интерфейс `INotifyPropertyChanged`. Он часто используется в паттернах [Presentation Model](http://martinfowler.com/eaaDev/PresentationModel.html) и [Model-View-ViewModel](http://msdn.microsoft.com/en-us/magazine/dd419663.aspx).

### <a name="av1235"></a> Не отправляйте `null` в качестве аргумента при вызове события (AV1235) ![](images/1.png)

Зачастую обработчик событий используется для обработки схожих событий от множества отправителей. В таком случае передаваемый аргумент используется для того, чтобы передать контекст вызова события. Всегда отправляйте ссылку на контекст (обычно `this`) при вызове события. Кроме того, не отправляйте `null` при вызове события, если оно не имеет данных. Если событие не имеет данных, отправьте `EventArgs.Empty` вместо `null`.

**Исключение:** Для статических событий передаваемый аргумент должен быть `null`.

### <a name="av1240"></a> Используйте общие ограничения, если возможно (AV1240) ![](images/2.png)
Вместо приведения и преобразования типа из конкретного в общий и наоборот используйте ключевое слово `where` или оператор `as`, чтобы привести объект к конкретному типу. Например:

	class SomeClass  
	{}
	
	// Неправильно  
	class MyClass  
	{
		void SomeMethod(T t)  
		{  
			object temp = t;  
			SomeClass obj = (SomeClass) temp;  
		}  
	}
	
	// Правильно  
	class MyClass where T : SomeClass  
	{
		void SomeMethod(T t)  
		{  
			SomeClass obj = t;  
		}  
	}

### <a name="av1250"></a> Вычисляйте результат LINQ-запроса до того, как вернуть его (AV1250) ![](images/1.png)

Посмотрите на следующий код:
	
	public IEnumerable GetGoldMemberCustomers()
	{
		const decimal GoldMemberThresholdInEuro = 1000000;
		
		var query = from customer in db.Customers
					where customer.Balance > GoldMemberThresholdInEuro
					select new GoldMember(customer.Name, customer.Balance);
		
		return query;  
	}

Поскольку LINQ-запросы используют отложенное выполнение, возвращение `q`, как это ни странно, вернет древо выражения, представляющее вышеуказанный запрос. Всякий раз, когда пользователь вычисляет результат, используя `foreach` или что-то похожее, весь запрос выполняется заново, создавая каждый раз новые экземпляры `GoldMember`. Как следствие, вы не сможете использовать оператор `==`, чтобы сравнить различные экземпляры `GoldMember`. Вместо этого всегда явно вычисляйте результат LINQ-запроса, используя `ToList()`, `ToArray()` или схожие методы.